# 模式匹配

模式匹配是一种结构性的解构

## 模式匹配的两种模式

不可辩驳模式和可辩驳模式，不可辩驳模式是指模式可以完全跟它匹配的值相匹配，反过来就是可辩驳模式。

## 支持模式匹配的位置

1. let 声明
2. 函数和闭包参数
3. match 表达式
4. if let 表达式
5. while let 表达式
6. for 表达式

### let 声明

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main () {
    let (a, b) = (1, 2);
    let Point {x, y} = Point { x: 3, y: 4 };

    assert_eq!(a, 1);
    assert_eq!(b, 2);
    assert_eq!(x, 3);
    assert_eq!(y, 4);
}
```

### 函数和闭包参数

```rust
fn sum(x: String, ref y: String) -> String {
    x + y
}

fn main () {
    let s = sum("1".to_owned(), "2".to_owned());
    assert_eq!(s, "12".to_owned());
}
```

ref 模式 等价于 &(mut)T 引用

```rust
fn main () {
    let a = 42;
    let ref b = a;
    let c = &a;
    assert_eq!(b, c);

    let mut a = [1, 2, 3];
    let ref mut b = a;
    b[0] = 0;
    assert_eq!(a, [0, 2, 3]);
}
```

### match 表达式

```rust
fn check_optional(opt: Option<i32>) {
    match opt {
        Some(p) => println!("has value {}", p),
        None => println!("has no value"),
    }
}

fn handle_result(res: i32) -> Result<i32, dyn Error> {
    do_something(res)?;
    // 问号操作符等价于
    match do_something(res) {
        Ok(o) => Ok(o),
        Err(e) => return SomeError(e),
    }
}
```

#### match 表达式演进

```rust
fn f(x: &Option<String>) {
    match x { // 这里是位置上下文，编译期自动对 x 进行解引用
        Some(s) => println!("{:?}", s), // 对 Some(s)，编译期自动插入 ref 模式
        None => {}
    }
}

fn main () {
    let x = Some("hello".to_owned());
    f(&x);
}
```

#### 切片和动态数组模式

```rust
fn main () {
    let arr = [1, 2, 3];
    match arr {
        [1, _, _] => "starts with one",
        [a, b, c] => "starts with something else",
    };

    // 动态大小数组
    let v = vec![1, 2, 3];
    match v[..] {
        [a, b] => { /* 不匹配 */ },
        [a, b, c] => { println!("{}, {}, {}", a, b ,c) } // 1, 2, 3
        _ => { /* 必须包含这条分支，因为长度是动态的  */ }
    }
}
```

### if let 表达式

```rust
fn main () {
    let x = &Some(3);

    if let Some(y) = x { // 这里会自动插入 ref 模式
        y; // &i32
    }
}
```

TODO

while let

for 表达式
