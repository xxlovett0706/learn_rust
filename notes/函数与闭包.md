# 函数与闭包

## 常规函数

特点：

1. 函数都拥有显式的类型签名
2. 函数可以分为三种类型：自由函数、关联函数和方法
3. 函数自身也是一种类型

### 自由函数

```rust
fn sum(a: i32, b: i32) -> i32 {
    a + b
}

fn main () {
    assert_eq!(sum(1, 2), 3);
    // sum(1, "2"); // error: 不满足函数签名的类型约定
}
```

### 关联函数和方法

```rust
struct A(i32, i32);

impl A {
    // 关联函数
    fn sum(a: i32, b: i32) -> i32 {
        a + b
    }

    // 方法
    fn math(&self) -> i32 {
        Self::sum(self.0, self.1)
    }
}

fn main () {
    let a = A(1, 2);
    assert_eq!(A::sum(1, 2), 3);
    assert_eq!(a.math(); 3);
}
```

### 函数项类型

```rust
struct A(i32, i32);
impl A {
    fn sum(a: i32, b: i32) -> i32 {
        a + b
    }
    fn math(&self) -> i32 {
        Self::sum(self.0, self.1)
    }
}

fn main () {
    let a = A(1, 2);
    let add = A::sum; // A::sum 是一个 fn item 类型
    let add_math = A::math; // A::math 也是一个 fn item 类型
    assert_eq!(add(1, 2), A::sum(1, 2));
    assert_eq!(add_math(&a), a.math());
}
```

函数项类型属于**零大小类型的类型构造器**，枚举中的项也类似。

```rust
enum Color {
    R(i16),
    G(i16),
    B(i16),
}

// 等价于
// fn Color::R(_1: i16) -> Color { /* ... */ }
// fn Color::G(_1: i16) -> Color { /* ... */ }
// fn Color::B(_1: i16) -> Color { /* ... */ }
// 零大小类型

fn main () {
    println!("{:?}", std::mem::size_of_val(&Color::R)); // 0
}
```

函数项默认实现了 Copy/Clone/Sync/Send/Fn/FnMut/FnOnce trait

## 函数指针

函数项隐式转换为函数指针

```rust
type RGB = (i16, i16, i16);

fn color(c: &str) -> RGB {
    (1, 1, 1)
}

fn show(c: fn(&str) -> RGB) {
    pritnln!("{:?}", c("black"));
}

fn main () {
    let rgb = color; // 函数项类型（fn item type）
    // let c: fn(&str) -> RGB = rgb; // 隐式转换为函数指针类型（fn pointer type）
    show(rgb); // (1, 1, 1)

    println!("{:?}", std::mem::size_of_val(&rgb)); // 0
    println!("{:?}", std::mem::size_of_val(&c)); // 8
}
```

**这里要注意函数项所占内存空间为 0 个字节，函数指针类型是占 8 个字节**

### 结论

1. 函数项类型可以通过显式指定函数类型转换为一个函数指针类型
2. 在写代码的时候，尽可能地去使用函数项类型，不到万不得已不要使用函数指针类型，这样有助于享受零大小类型的优化

## 闭包

闭包其实是编译期的语法糖，根据是否捕获变量，以及捕获变量的类型，来选择相应的 trait 实现。

### 函数无法捕获环境变量

```rust
fn counter(i: i32) -> fn(i32) -> i32 {
    fn inc(n: i32) -> i32 {
        n + i // error[E0434]: can't capture dynamic environment in a fn item
    }

    inc
}

fn main () {
    let f = counter(2);
    assert_eq!(f(1), 3);
}
```

**函数没有权利捕获环境中自由变量的权利**

### 闭包可以捕获环境变量

```rust
fn counter(i: i32) -> impl FnMut(i32) -> i32 {
    move |n| n + i
}

fn main () {
    let mut f = counter(2);
    assert_eq!(f(1), 3);
}
```

### 闭包与函数指针互通

```rust
type RGB = (i16, i16, i16);

fn color(c: &str) -> RGB {
    (1, 1, 1)
}

fn show(c: fn(&str) -> RGB) {
    pritnln!("{:?}", c("black"));
}

fn main () {
    let rgb = color; // 函数项类型（fn item type）
    show(rgb); // (1, 1, 1)
    // 定义了实现 `Fn(&str) -> RGB` trait 的闭包类型
    let c = |s: &str| {(1, 2, 3)};
    show(c); // (1, 2, 3)
}
```

### 按使用场景分类

1. 为捕获环境变量 => 所有权（Ownership）
2. 捕获并修改环境变量 => 可变借用（&mut T）
3. 捕获并未修改环境变量 => 不可变借用（&T）

```rust
fn main () {
    // 未捕获环境变量
    let c1 = || println!("hello");
    c1();

    // 可修改环境变量
    let mut arr = [1, 2, 3];
    let mut c2 = |i| {
        arr[0] = i;
        println!("{:?}", arr);
    };
    c2(0);

    // 未修改环境变量
    let answer = 42;
    let c3 = || {
        println!("The answer is {}", answer);
    }
}
```

### 闭包的类型

1. 如果没有任何捕获变量，则实现 FnOnce。
2. 如果有捕获变量，并且会对捕获变量进行修改，则实现 FnMut。
3. 如果有捕获变量，并且不会对捕获变量进行修改，则实现 Fn。

特殊情况：

1. 编译期会把 FnOnce 当成 fn(T)函数指摘去看待。
2. Fn/FnMut/FnOnce 这三者 trait 的关系是依次继承，它们正好对应所有权三件套

TODO 自定义闭包调用

### 逃逸闭包与非逃逸闭包

```rust
#![feature(unboxed_closures, fn_traits)]
fn c_mut() -> impl FnMut(i32) -> [i32; 3] {
  let mut arr = [0, 1, 2];
  move |i| { arr[0] = i; arr }
}

fn main () {
  let i = 42;
  let mut arr_closure = c_mut();

  println!("{:?}", arr_closure.call_once((i,)));
  println!("{:?}", arr_closure(i));
}
```

```rust
// Error: FnMut 不能用做逃逸闭包
fn c_mut2() -> impl for<'a> FnMut(&'a str) -> String {
  let mut s = "hello ".to_string();
  move |i| { s+= i; s }
}

fn main () {
  let i = "world";
  let mut arr_closure = c_mut2(); // Error
}
```

### 特殊情况：唯一不可变借用

```rust
fn main () {
  let mut a = [1, 2 ,3];
  let x = &mut a;
  {
    let mut c = || { (*x)[0] = 0; };
    let y = &x; // Error
    c();
  }
  let z = &x; // Ok
}
```

### 闭包自身实现哪些 trait

1. Sized 所有闭包默认实现
2. Copy/Clone **取决于环境变量是否实现 Copy，以及它如何被闭包使用的**
3. Sync/Send

实现 Copy/Clone 的两条简单规则：

1. 如果环境变量实现了 Copy， 闭包如果以可变借用方式捕获环境变量，并对其进行修改，则闭包自身不会实现 Copy。
2. 如果环境变量自身是 Move 语义，则闭包内捕获环境变量的操作涉及修改环境变量或者消耗环境变量，则闭包自身不会实现 Copy。

```rust
fn foo<F: Fn() + Copy>(f: F) {
    f()
}

fn main() {
    let s = "hello".to_owned();
    let f = || {
        println!("{}", s);
    };

    foo(f); // Ok
}
```

```rust
fn foo<F:Fn() + Copy>(f: F) {
  f()
}

fn main () {
  let s = "hello".to_owned();
  let f = move || {
    println!("{}", x);
  };

  foo(f); // Error
}
```

实现 Sync/Send 的三条简单规则：

1. 如果所有捕获变量均实现了 Sync，则闭包实现 Sync。
2. 如果环境变量都不是**唯一不可变引用**方式捕获的，并且都实现了 Sync，则闭包实现 Send。
3. 如果环境变量是以**唯一不可变引用**、**可变引用**、Copy 或 Move 所有权捕获的，那闭包实现 Send。
